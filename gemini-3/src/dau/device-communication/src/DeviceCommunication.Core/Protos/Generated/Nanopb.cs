// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: nanopb.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
/// <summary>Holder for reflection information generated from nanopb.proto</summary>
public static partial class NanopbReflection {

  #region Descriptor
  /// <summary>File descriptor for nanopb.proto</summary>
  public static pbr::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbr::FileDescriptor descriptor;

  static NanopbReflection() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "CgxuYW5vcGIucHJvdG8aIGdvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLnBy",
          "b3RvIpkJCg1OYW5vUEJPcHRpb25zEhAKCG1heF9zaXplGAEgASgFEhIKCm1h",
          "eF9sZW5ndGgYDiABKAUSEQoJbWF4X2NvdW50GAIgASgFEiYKCGludF9zaXpl",
          "GAcgASgOMgguSW50U2l6ZToKSVNfREVGQVVMVBIqCgxlbnVtX2ludHNpemUY",
          "IiABKA4yCC5JbnRTaXplOgpJU19ERUZBVUxUEiQKBHR5cGUYAyABKA4yCi5G",
          "aWVsZFR5cGU6CkZUX0RFRkFVTFQSGAoKbG9uZ19uYW1lcxgEIAEoCDoEdHJ1",
          "ZRIcCg1wYWNrZWRfc3RydWN0GAUgASgIOgVmYWxzZRIaCgtwYWNrZWRfZW51",
          "bRgKIAEoCDoFZmFsc2USGwoMc2tpcF9tZXNzYWdlGAYgASgIOgVmYWxzZRIY",
          "Cglub191bmlvbnMYCCABKAg6BWZhbHNlEg0KBW1zZ2lkGAkgASgNEh4KD2Fu",
          "b255bW91c19vbmVvZhgLIAEoCDoFZmFsc2USFQoGcHJvdG8zGAwgASgIOgVm",
          "YWxzZRIjChRwcm90bzNfc2luZ3VsYXJfbXNncxgVIAEoCDoFZmFsc2USHQoO",
          "ZW51bV90b19zdHJpbmcYDSABKAg6BWZhbHNlEhwKDWVudW1fdmFsaWRhdGUY",
          "ICABKAg6BWZhbHNlEhsKDGZpeGVkX2xlbmd0aBgPIAEoCDoFZmFsc2USGgoL",
          "Zml4ZWRfY291bnQYECABKAg6BWZhbHNlEh4KD3N1Ym1zZ19jYWxsYmFjaxgW",
          "IAEoCDoFZmFsc2USLwoMbWFuZ2xlX25hbWVzGBEgASgOMhEuVHlwZW5hbWVN",
          "YW5nbGluZzoGTV9OT05FEigKEWNhbGxiYWNrX2RhdGF0eXBlGBIgASgJOg1w",
          "Yl9jYWxsYmFja190EjQKEWNhbGxiYWNrX2Z1bmN0aW9uGBMgASgJOhlwYl9k",
          "ZWZhdWx0X2ZpZWxkX2NhbGxiYWNrEjAKDmRlc2NyaXB0b3JzaXplGBQgASgO",
          "Mg8uRGVzY3JpcHRvclNpemU6B0RTX0FVVE8SGgoLZGVmYXVsdF9oYXMYFyAB",
          "KAg6BWZhbHNlEg8KB2luY2x1ZGUYGCADKAkSDwoHZXhjbHVkZRgaIAMoCRIP",
          "CgdwYWNrYWdlGBkgASgJEkEKDXR5cGVfb3ZlcnJpZGUYGyABKA4yKi5nb29n",
          "bGUucHJvdG9idWYuRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZRJDCg5sYWJl",
          "bF9vdmVycmlkZRgfIAEoDjIrLmdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2Ny",
          "aXB0b3JQcm90by5MYWJlbBIZCgtzb3J0X2J5X3RhZxgcIAEoCDoEdHJ1ZRIu",
          "Cg1mYWxsYmFja190eXBlGB0gASgOMgouRmllbGRUeXBlOgtGVF9DQUxMQkFD",
          "SxITCgtpbml0aWFsaXplchgeIAEoCRIsCh5kaXNjYXJkX3VudXNlZF9hdXRv",
          "bWF0aWNfdHlwZXMYISABKAg6BHRydWUSIQoSZGlzY2FyZF9kZXByZWNhdGVk",
          "GCMgASgIOgVmYWxzZSppCglGaWVsZFR5cGUSDgoKRlRfREVGQVVMVBAAEg8K",
          "C0ZUX0NBTExCQUNLEAESDgoKRlRfUE9JTlRFUhAEEg0KCUZUX1NUQVRJQxAC",
          "Eg0KCUZUX0lHTk9SRRADEg0KCUZUX0lOTElORRAFKkQKB0ludFNpemUSDgoK",
          "SVNfREVGQVVMVBAAEggKBElTXzgQCBIJCgVJU18xNhAQEgkKBUlTXzMyECAS",
          "CQoFSVNfNjQQQCpaChBUeXBlbmFtZU1hbmdsaW5nEgoKBk1fTk9ORRAAEhMK",
          "D01fU1RSSVBfUEFDS0FHRRABEg0KCU1fRkxBVFRFThACEhYKEk1fUEFDS0FH",
          "RV9JTklUSUFMUxADKkUKDkRlc2NyaXB0b3JTaXplEgsKB0RTX0FVVE8QABII",
          "CgREU18xEAESCAoERFNfMhACEggKBERTXzQQBBIICgREU184EAg6RQoObmFu",
          "b3BiX2ZpbGVvcHQSHC5nb29nbGUucHJvdG9idWYuRmlsZU9wdGlvbnMY8gcg",
          "ASgLMg4uTmFub1BCT3B0aW9uczpHCg1uYW5vcGJfbXNnb3B0Eh8uZ29vZ2xl",
          "LnByb3RvYnVmLk1lc3NhZ2VPcHRpb25zGPIHIAEoCzIOLk5hbm9QQk9wdGlv",
          "bnM6RQoObmFub3BiX2VudW1vcHQSHC5nb29nbGUucHJvdG9idWYuRW51bU9w",
          "dGlvbnMY8gcgASgLMg4uTmFub1BCT3B0aW9uczo+CgZuYW5vcGISHS5nb29n",
          "bGUucHJvdG9idWYuRmllbGRPcHRpb25zGPIHIAEoCzIOLk5hbm9QQk9wdGlv",
          "bnNCGgoYZmkua2Fwc2kua290aS5qcGEubmFub3Bi"));
    descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
        new pbr::FileDescriptor[] { global::Google.Protobuf.Reflection.DescriptorReflection.Descriptor, },
        new pbr::GeneratedClrTypeInfo(new[] {typeof(global::FieldType), typeof(global::IntSize), typeof(global::TypenameMangling), typeof(global::DescriptorSize), }, new pb::Extension[] { NanopbExtensions.NanopbFileopt, NanopbExtensions.NanopbMsgopt, NanopbExtensions.NanopbEnumopt, NanopbExtensions.Nanopb }, new pbr::GeneratedClrTypeInfo[] {
          new pbr::GeneratedClrTypeInfo(typeof(global::NanoPBOptions), global::NanoPBOptions.Parser, new[]{ "MaxSize", "MaxLength", "MaxCount", "IntSize", "EnumIntsize", "Type", "LongNames", "PackedStruct", "PackedEnum", "SkipMessage", "NoUnions", "Msgid", "AnonymousOneof", "Proto3", "Proto3SingularMsgs", "EnumToString", "EnumValidate", "FixedLength", "FixedCount", "SubmsgCallback", "MangleNames", "CallbackDatatype", "CallbackFunction", "Descriptorsize", "DefaultHas", "Include", "Exclude", "Package", "TypeOverride", "LabelOverride", "SortByTag", "FallbackType", "Initializer", "DiscardUnusedAutomaticTypes", "DiscardDeprecated" }, null, null, null, null)
        }));
  }
  #endregion

}
/// <summary>Holder for extension identifiers generated from the top level of nanopb.proto</summary>
public static partial class NanopbExtensions {
  public static readonly pb::Extension<global::Google.Protobuf.Reflection.FileOptions, global::NanoPBOptions> NanopbFileopt =
    new pb::Extension<global::Google.Protobuf.Reflection.FileOptions, global::NanoPBOptions>(1010, pb::FieldCodec.ForMessage(8082, global::NanoPBOptions.Parser));
  public static readonly pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::NanoPBOptions> NanopbMsgopt =
    new pb::Extension<global::Google.Protobuf.Reflection.MessageOptions, global::NanoPBOptions>(1010, pb::FieldCodec.ForMessage(8082, global::NanoPBOptions.Parser));
  public static readonly pb::Extension<global::Google.Protobuf.Reflection.EnumOptions, global::NanoPBOptions> NanopbEnumopt =
    new pb::Extension<global::Google.Protobuf.Reflection.EnumOptions, global::NanoPBOptions>(1010, pb::FieldCodec.ForMessage(8082, global::NanoPBOptions.Parser));
  public static readonly pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::NanoPBOptions> Nanopb =
    new pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::NanoPBOptions>(1010, pb::FieldCodec.ForMessage(8082, global::NanoPBOptions.Parser));
}

#region Enums
public enum FieldType {
  /// <summary>
  /// Automatically decide field type, generate static field if possible.
  /// </summary>
  [pbr::OriginalName("FT_DEFAULT")] FtDefault = 0,
  /// <summary>
  /// Always generate a callback field.
  /// </summary>
  [pbr::OriginalName("FT_CALLBACK")] FtCallback = 1,
  /// <summary>
  /// Always generate a dynamically allocated field.
  /// </summary>
  [pbr::OriginalName("FT_POINTER")] FtPointer = 4,
  /// <summary>
  /// Generate a static field or raise an exception if not possible.
  /// </summary>
  [pbr::OriginalName("FT_STATIC")] FtStatic = 2,
  /// <summary>
  /// Ignore the field completely.
  /// </summary>
  [pbr::OriginalName("FT_IGNORE")] FtIgnore = 3,
  /// <summary>
  /// Legacy option, use the separate 'fixed_length' option instead
  /// </summary>
  [pbr::OriginalName("FT_INLINE")] FtInline = 5,
}

public enum IntSize {
  /// <summary>
  /// Default, 32/64bit based on type in .proto
  /// </summary>
  [pbr::OriginalName("IS_DEFAULT")] IsDefault = 0,
  [pbr::OriginalName("IS_8")] Is8 = 8,
  [pbr::OriginalName("IS_16")] Is16 = 16,
  [pbr::OriginalName("IS_32")] Is32 = 32,
  [pbr::OriginalName("IS_64")] Is64 = 64,
}

public enum TypenameMangling {
  /// <summary>
  /// Default, no typename mangling
  /// </summary>
  [pbr::OriginalName("M_NONE")] MNone = 0,
  /// <summary>
  /// Strip current package name
  /// </summary>
  [pbr::OriginalName("M_STRIP_PACKAGE")] MStripPackage = 1,
  /// <summary>
  /// Only use last path component
  /// </summary>
  [pbr::OriginalName("M_FLATTEN")] MFlatten = 2,
  /// <summary>
  /// Replace the package name by the initials
  /// </summary>
  [pbr::OriginalName("M_PACKAGE_INITIALS")] MPackageInitials = 3,
}

public enum DescriptorSize {
  /// <summary>
  /// Select minimal size based on field type
  /// </summary>
  [pbr::OriginalName("DS_AUTO")] DsAuto = 0,
  /// <summary>
  /// 1 word; up to 15 byte fields, no arrays
  /// </summary>
  [pbr::OriginalName("DS_1")] Ds1 = 1,
  /// <summary>
  /// 2 words; up to 4095 byte fields, 4095 entry arrays
  /// </summary>
  [pbr::OriginalName("DS_2")] Ds2 = 2,
  /// <summary>
  /// 4 words; up to 2^32-1 byte fields, 2^16-1 entry arrays
  /// </summary>
  [pbr::OriginalName("DS_4")] Ds4 = 4,
  /// <summary>
  /// 8 words; up to 2^32-1 entry arrays
  /// </summary>
  [pbr::OriginalName("DS_8")] Ds8 = 8,
}

#endregion

#region Messages
/// <summary>
/// This is the inner options message, which basically defines options for
/// a field. When it is used in message or file scope, it applies to all
/// fields.
/// </summary>
[global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
public sealed partial class NanoPBOptions : pb::IMessage<NanoPBOptions>
#if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    , pb::IBufferMessage
#endif
{
  private static readonly pb::MessageParser<NanoPBOptions> _parser = new pb::MessageParser<NanoPBOptions>(() => new NanoPBOptions());
  private pb::UnknownFieldSet _unknownFields;
  private int _hasBits0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public static pb::MessageParser<NanoPBOptions> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public static pbr::MessageDescriptor Descriptor {
    get { return global::NanopbReflection.Descriptor.MessageTypes[0]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  pbr::MessageDescriptor pb::IMessage.Descriptor {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public NanoPBOptions() {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public NanoPBOptions(NanoPBOptions other) : this() {
    _hasBits0 = other._hasBits0;
    maxSize_ = other.maxSize_;
    maxLength_ = other.maxLength_;
    maxCount_ = other.maxCount_;
    intSize_ = other.intSize_;
    enumIntsize_ = other.enumIntsize_;
    type_ = other.type_;
    longNames_ = other.longNames_;
    packedStruct_ = other.packedStruct_;
    packedEnum_ = other.packedEnum_;
    skipMessage_ = other.skipMessage_;
    noUnions_ = other.noUnions_;
    msgid_ = other.msgid_;
    anonymousOneof_ = other.anonymousOneof_;
    proto3_ = other.proto3_;
    proto3SingularMsgs_ = other.proto3SingularMsgs_;
    enumToString_ = other.enumToString_;
    enumValidate_ = other.enumValidate_;
    fixedLength_ = other.fixedLength_;
    fixedCount_ = other.fixedCount_;
    submsgCallback_ = other.submsgCallback_;
    mangleNames_ = other.mangleNames_;
    callbackDatatype_ = other.callbackDatatype_;
    callbackFunction_ = other.callbackFunction_;
    descriptorsize_ = other.descriptorsize_;
    defaultHas_ = other.defaultHas_;
    include_ = other.include_.Clone();
    exclude_ = other.exclude_.Clone();
    package_ = other.package_;
    typeOverride_ = other.typeOverride_;
    labelOverride_ = other.labelOverride_;
    sortByTag_ = other.sortByTag_;
    fallbackType_ = other.fallbackType_;
    initializer_ = other.initializer_;
    discardUnusedAutomaticTypes_ = other.discardUnusedAutomaticTypes_;
    discardDeprecated_ = other.discardDeprecated_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public NanoPBOptions Clone() {
    return new NanoPBOptions(this);
  }

  /// <summary>Field number for the "max_size" field.</summary>
  public const int MaxSizeFieldNumber = 1;
  private readonly static int MaxSizeDefaultValue = 0;

  private int maxSize_;
  /// <summary>
  /// Allocated size for 'bytes' and 'string' fields.
  /// For string fields, this should include the space for null terminator.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public int MaxSize {
    get { if ((_hasBits0 & 1) != 0) { return maxSize_; } else { return MaxSizeDefaultValue; } }
    set {
      _hasBits0 |= 1;
      maxSize_ = value;
    }
  }
  /// <summary>Gets whether the "max_size" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasMaxSize {
    get { return (_hasBits0 & 1) != 0; }
  }
  /// <summary>Clears the value of the "max_size" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearMaxSize() {
    _hasBits0 &= ~1;
  }

  /// <summary>Field number for the "max_length" field.</summary>
  public const int MaxLengthFieldNumber = 14;
  private readonly static int MaxLengthDefaultValue = 0;

  private int maxLength_;
  /// <summary>
  /// Maximum length for 'string' fields. Setting this is equivalent
  /// to setting max_size to a value of length+1.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public int MaxLength {
    get { if ((_hasBits0 & 8192) != 0) { return maxLength_; } else { return MaxLengthDefaultValue; } }
    set {
      _hasBits0 |= 8192;
      maxLength_ = value;
    }
  }
  /// <summary>Gets whether the "max_length" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasMaxLength {
    get { return (_hasBits0 & 8192) != 0; }
  }
  /// <summary>Clears the value of the "max_length" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearMaxLength() {
    _hasBits0 &= ~8192;
  }

  /// <summary>Field number for the "max_count" field.</summary>
  public const int MaxCountFieldNumber = 2;
  private readonly static int MaxCountDefaultValue = 0;

  private int maxCount_;
  /// <summary>
  /// Allocated number of entries in arrays ('repeated' fields)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public int MaxCount {
    get { if ((_hasBits0 & 2) != 0) { return maxCount_; } else { return MaxCountDefaultValue; } }
    set {
      _hasBits0 |= 2;
      maxCount_ = value;
    }
  }
  /// <summary>Gets whether the "max_count" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasMaxCount {
    get { return (_hasBits0 & 2) != 0; }
  }
  /// <summary>Clears the value of the "max_count" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearMaxCount() {
    _hasBits0 &= ~2;
  }

  /// <summary>Field number for the "int_size" field.</summary>
  public const int IntSizeFieldNumber = 7;
  private readonly static global::IntSize IntSizeDefaultValue = global::IntSize.IsDefault;

  private global::IntSize intSize_;
  /// <summary>
  /// Size of integer fields. Can save some memory if you don't need
  /// full 32 bits for the value.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::IntSize IntSize {
    get { if ((_hasBits0 & 64) != 0) { return intSize_; } else { return IntSizeDefaultValue; } }
    set {
      _hasBits0 |= 64;
      intSize_ = value;
    }
  }
  /// <summary>Gets whether the "int_size" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasIntSize {
    get { return (_hasBits0 & 64) != 0; }
  }
  /// <summary>Clears the value of the "int_size" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearIntSize() {
    _hasBits0 &= ~64;
  }

  /// <summary>Field number for the "enum_intsize" field.</summary>
  public const int EnumIntsizeFieldNumber = 34;
  private readonly static global::IntSize EnumIntsizeDefaultValue = global::IntSize.IsDefault;

  private global::IntSize enumIntsize_;
  /// <summary>
  /// Size for enum fields. Supported by C++11 and C23 standards.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::IntSize EnumIntsize {
    get { if ((_hasBits0 & 134217728) != 0) { return enumIntsize_; } else { return EnumIntsizeDefaultValue; } }
    set {
      _hasBits0 |= 134217728;
      enumIntsize_ = value;
    }
  }
  /// <summary>Gets whether the "enum_intsize" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasEnumIntsize {
    get { return (_hasBits0 & 134217728) != 0; }
  }
  /// <summary>Clears the value of the "enum_intsize" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearEnumIntsize() {
    _hasBits0 &= ~134217728;
  }

  /// <summary>Field number for the "type" field.</summary>
  public const int TypeFieldNumber = 3;
  private readonly static global::FieldType TypeDefaultValue = global::FieldType.FtDefault;

  private global::FieldType type_;
  /// <summary>
  /// Force type of field (callback or static allocation)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::FieldType Type {
    get { if ((_hasBits0 & 4) != 0) { return type_; } else { return TypeDefaultValue; } }
    set {
      _hasBits0 |= 4;
      type_ = value;
    }
  }
  /// <summary>Gets whether the "type" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasType {
    get { return (_hasBits0 & 4) != 0; }
  }
  /// <summary>Clears the value of the "type" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearType() {
    _hasBits0 &= ~4;
  }

  /// <summary>Field number for the "long_names" field.</summary>
  public const int LongNamesFieldNumber = 4;
  private readonly static bool LongNamesDefaultValue = true;

  private bool longNames_;
  /// <summary>
  /// Use long names for enums, i.e. EnumName_EnumValue.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool LongNames {
    get { if ((_hasBits0 & 8) != 0) { return longNames_; } else { return LongNamesDefaultValue; } }
    set {
      _hasBits0 |= 8;
      longNames_ = value;
    }
  }
  /// <summary>Gets whether the "long_names" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasLongNames {
    get { return (_hasBits0 & 8) != 0; }
  }
  /// <summary>Clears the value of the "long_names" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearLongNames() {
    _hasBits0 &= ~8;
  }

  /// <summary>Field number for the "packed_struct" field.</summary>
  public const int PackedStructFieldNumber = 5;
  private readonly static bool PackedStructDefaultValue = false;

  private bool packedStruct_;
  /// <summary>
  /// Add 'packed' attribute to generated structs.
  /// Note: this cannot be used on CPUs that break on unaligned
  /// accesses to variables.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool PackedStruct {
    get { if ((_hasBits0 & 16) != 0) { return packedStruct_; } else { return PackedStructDefaultValue; } }
    set {
      _hasBits0 |= 16;
      packedStruct_ = value;
    }
  }
  /// <summary>Gets whether the "packed_struct" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasPackedStruct {
    get { return (_hasBits0 & 16) != 0; }
  }
  /// <summary>Clears the value of the "packed_struct" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearPackedStruct() {
    _hasBits0 &= ~16;
  }

  /// <summary>Field number for the "packed_enum" field.</summary>
  public const int PackedEnumFieldNumber = 10;
  private readonly static bool PackedEnumDefaultValue = false;

  private bool packedEnum_;
  /// <summary>
  /// Add 'packed' attribute to generated enums.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool PackedEnum {
    get { if ((_hasBits0 & 512) != 0) { return packedEnum_; } else { return PackedEnumDefaultValue; } }
    set {
      _hasBits0 |= 512;
      packedEnum_ = value;
    }
  }
  /// <summary>Gets whether the "packed_enum" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasPackedEnum {
    get { return (_hasBits0 & 512) != 0; }
  }
  /// <summary>Clears the value of the "packed_enum" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearPackedEnum() {
    _hasBits0 &= ~512;
  }

  /// <summary>Field number for the "skip_message" field.</summary>
  public const int SkipMessageFieldNumber = 6;
  private readonly static bool SkipMessageDefaultValue = false;

  private bool skipMessage_;
  /// <summary>
  /// Skip this message
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool SkipMessage {
    get { if ((_hasBits0 & 32) != 0) { return skipMessage_; } else { return SkipMessageDefaultValue; } }
    set {
      _hasBits0 |= 32;
      skipMessage_ = value;
    }
  }
  /// <summary>Gets whether the "skip_message" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasSkipMessage {
    get { return (_hasBits0 & 32) != 0; }
  }
  /// <summary>Clears the value of the "skip_message" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearSkipMessage() {
    _hasBits0 &= ~32;
  }

  /// <summary>Field number for the "no_unions" field.</summary>
  public const int NoUnionsFieldNumber = 8;
  private readonly static bool NoUnionsDefaultValue = false;

  private bool noUnions_;
  /// <summary>
  /// Generate oneof fields as normal optional fields instead of union.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool NoUnions {
    get { if ((_hasBits0 & 128) != 0) { return noUnions_; } else { return NoUnionsDefaultValue; } }
    set {
      _hasBits0 |= 128;
      noUnions_ = value;
    }
  }
  /// <summary>Gets whether the "no_unions" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasNoUnions {
    get { return (_hasBits0 & 128) != 0; }
  }
  /// <summary>Clears the value of the "no_unions" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearNoUnions() {
    _hasBits0 &= ~128;
  }

  /// <summary>Field number for the "msgid" field.</summary>
  public const int MsgidFieldNumber = 9;
  private readonly static uint MsgidDefaultValue = 0;

  private uint msgid_;
  /// <summary>
  /// integer type tag for a message
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public uint Msgid {
    get { if ((_hasBits0 & 256) != 0) { return msgid_; } else { return MsgidDefaultValue; } }
    set {
      _hasBits0 |= 256;
      msgid_ = value;
    }
  }
  /// <summary>Gets whether the "msgid" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasMsgid {
    get { return (_hasBits0 & 256) != 0; }
  }
  /// <summary>Clears the value of the "msgid" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearMsgid() {
    _hasBits0 &= ~256;
  }

  /// <summary>Field number for the "anonymous_oneof" field.</summary>
  public const int AnonymousOneofFieldNumber = 11;
  private readonly static bool AnonymousOneofDefaultValue = false;

  private bool anonymousOneof_;
  /// <summary>
  /// decode oneof as anonymous union
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool AnonymousOneof {
    get { if ((_hasBits0 & 1024) != 0) { return anonymousOneof_; } else { return AnonymousOneofDefaultValue; } }
    set {
      _hasBits0 |= 1024;
      anonymousOneof_ = value;
    }
  }
  /// <summary>Gets whether the "anonymous_oneof" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasAnonymousOneof {
    get { return (_hasBits0 & 1024) != 0; }
  }
  /// <summary>Clears the value of the "anonymous_oneof" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearAnonymousOneof() {
    _hasBits0 &= ~1024;
  }

  /// <summary>Field number for the "proto3" field.</summary>
  public const int Proto3FieldNumber = 12;
  private readonly static bool Proto3DefaultValue = false;

  private bool proto3_;
  /// <summary>
  /// Proto3 singular field does not generate a "has_" flag
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool Proto3 {
    get { if ((_hasBits0 & 2048) != 0) { return proto3_; } else { return Proto3DefaultValue; } }
    set {
      _hasBits0 |= 2048;
      proto3_ = value;
    }
  }
  /// <summary>Gets whether the "proto3" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasProto3 {
    get { return (_hasBits0 & 2048) != 0; }
  }
  /// <summary>Clears the value of the "proto3" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearProto3() {
    _hasBits0 &= ~2048;
  }

  /// <summary>Field number for the "proto3_singular_msgs" field.</summary>
  public const int Proto3SingularMsgsFieldNumber = 21;
  private readonly static bool Proto3SingularMsgsDefaultValue = false;

  private bool proto3SingularMsgs_;
  /// <summary>
  /// Force proto3 messages to have no "has_" flag.
  /// This was default behavior until nanopb-0.4.0.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool Proto3SingularMsgs {
    get { if ((_hasBits0 & 262144) != 0) { return proto3SingularMsgs_; } else { return Proto3SingularMsgsDefaultValue; } }
    set {
      _hasBits0 |= 262144;
      proto3SingularMsgs_ = value;
    }
  }
  /// <summary>Gets whether the "proto3_singular_msgs" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasProto3SingularMsgs {
    get { return (_hasBits0 & 262144) != 0; }
  }
  /// <summary>Clears the value of the "proto3_singular_msgs" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearProto3SingularMsgs() {
    _hasBits0 &= ~262144;
  }

  /// <summary>Field number for the "enum_to_string" field.</summary>
  public const int EnumToStringFieldNumber = 13;
  private readonly static bool EnumToStringDefaultValue = false;

  private bool enumToString_;
  /// <summary>
  /// Generate an enum->string mapping function (can take up lots of space).
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool EnumToString {
    get { if ((_hasBits0 & 4096) != 0) { return enumToString_; } else { return EnumToStringDefaultValue; } }
    set {
      _hasBits0 |= 4096;
      enumToString_ = value;
    }
  }
  /// <summary>Gets whether the "enum_to_string" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasEnumToString {
    get { return (_hasBits0 & 4096) != 0; }
  }
  /// <summary>Clears the value of the "enum_to_string" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearEnumToString() {
    _hasBits0 &= ~4096;
  }

  /// <summary>Field number for the "enum_validate" field.</summary>
  public const int EnumValidateFieldNumber = 32;
  private readonly static bool EnumValidateDefaultValue = false;

  private bool enumValidate_;
  /// <summary>
  /// Generate validation methods for enums
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool EnumValidate {
    get { if ((_hasBits0 & 33554432) != 0) { return enumValidate_; } else { return EnumValidateDefaultValue; } }
    set {
      _hasBits0 |= 33554432;
      enumValidate_ = value;
    }
  }
  /// <summary>Gets whether the "enum_validate" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasEnumValidate {
    get { return (_hasBits0 & 33554432) != 0; }
  }
  /// <summary>Clears the value of the "enum_validate" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearEnumValidate() {
    _hasBits0 &= ~33554432;
  }

  /// <summary>Field number for the "fixed_length" field.</summary>
  public const int FixedLengthFieldNumber = 15;
  private readonly static bool FixedLengthDefaultValue = false;

  private bool fixedLength_;
  /// <summary>
  /// Generate bytes arrays with fixed length
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool FixedLength {
    get { if ((_hasBits0 & 16384) != 0) { return fixedLength_; } else { return FixedLengthDefaultValue; } }
    set {
      _hasBits0 |= 16384;
      fixedLength_ = value;
    }
  }
  /// <summary>Gets whether the "fixed_length" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasFixedLength {
    get { return (_hasBits0 & 16384) != 0; }
  }
  /// <summary>Clears the value of the "fixed_length" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearFixedLength() {
    _hasBits0 &= ~16384;
  }

  /// <summary>Field number for the "fixed_count" field.</summary>
  public const int FixedCountFieldNumber = 16;
  private readonly static bool FixedCountDefaultValue = false;

  private bool fixedCount_;
  /// <summary>
  /// Generate repeated field with fixed count
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool FixedCount {
    get { if ((_hasBits0 & 32768) != 0) { return fixedCount_; } else { return FixedCountDefaultValue; } }
    set {
      _hasBits0 |= 32768;
      fixedCount_ = value;
    }
  }
  /// <summary>Gets whether the "fixed_count" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasFixedCount {
    get { return (_hasBits0 & 32768) != 0; }
  }
  /// <summary>Clears the value of the "fixed_count" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearFixedCount() {
    _hasBits0 &= ~32768;
  }

  /// <summary>Field number for the "submsg_callback" field.</summary>
  public const int SubmsgCallbackFieldNumber = 22;
  private readonly static bool SubmsgCallbackDefaultValue = false;

  private bool submsgCallback_;
  /// <summary>
  /// Generate message-level callback that is called before decoding submessages.
  /// This can be used to set callback fields for submsgs inside oneofs.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool SubmsgCallback {
    get { if ((_hasBits0 & 524288) != 0) { return submsgCallback_; } else { return SubmsgCallbackDefaultValue; } }
    set {
      _hasBits0 |= 524288;
      submsgCallback_ = value;
    }
  }
  /// <summary>Gets whether the "submsg_callback" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasSubmsgCallback {
    get { return (_hasBits0 & 524288) != 0; }
  }
  /// <summary>Clears the value of the "submsg_callback" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearSubmsgCallback() {
    _hasBits0 &= ~524288;
  }

  /// <summary>Field number for the "mangle_names" field.</summary>
  public const int MangleNamesFieldNumber = 17;
  private readonly static global::TypenameMangling MangleNamesDefaultValue = global::TypenameMangling.MNone;

  private global::TypenameMangling mangleNames_;
  /// <summary>
  /// Shorten or remove package names from type names.
  /// This option applies only on the file level.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::TypenameMangling MangleNames {
    get { if ((_hasBits0 & 65536) != 0) { return mangleNames_; } else { return MangleNamesDefaultValue; } }
    set {
      _hasBits0 |= 65536;
      mangleNames_ = value;
    }
  }
  /// <summary>Gets whether the "mangle_names" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasMangleNames {
    get { return (_hasBits0 & 65536) != 0; }
  }
  /// <summary>Clears the value of the "mangle_names" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearMangleNames() {
    _hasBits0 &= ~65536;
  }

  /// <summary>Field number for the "callback_datatype" field.</summary>
  public const int CallbackDatatypeFieldNumber = 18;
  private readonly static string CallbackDatatypeDefaultValue = global::System.Text.Encoding.UTF8.GetString(global::System.Convert.FromBase64String("cGJfY2FsbGJhY2tfdA=="), 0, 13);

  private string callbackDatatype_;
  /// <summary>
  /// Data type for storage associated with callback fields.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public string CallbackDatatype {
    get { return callbackDatatype_ ?? CallbackDatatypeDefaultValue; }
    set {
      callbackDatatype_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }
  /// <summary>Gets whether the "callback_datatype" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasCallbackDatatype {
    get { return callbackDatatype_ != null; }
  }
  /// <summary>Clears the value of the "callback_datatype" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearCallbackDatatype() {
    callbackDatatype_ = null;
  }

  /// <summary>Field number for the "callback_function" field.</summary>
  public const int CallbackFunctionFieldNumber = 19;
  private readonly static string CallbackFunctionDefaultValue = global::System.Text.Encoding.UTF8.GetString(global::System.Convert.FromBase64String("cGJfZGVmYXVsdF9maWVsZF9jYWxsYmFjaw=="), 0, 25);

  private string callbackFunction_;
  /// <summary>
  /// Callback function used for encoding and decoding.
  /// Prior to nanopb-0.4.0, the callback was specified in per-field pb_callback_t
  /// structure. This is still supported, but does not work inside e.g. oneof or pointer
  /// fields. Instead, a new method allows specifying a per-message callback that
  /// will be called for all callback fields in a message type.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public string CallbackFunction {
    get { return callbackFunction_ ?? CallbackFunctionDefaultValue; }
    set {
      callbackFunction_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }
  /// <summary>Gets whether the "callback_function" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasCallbackFunction {
    get { return callbackFunction_ != null; }
  }
  /// <summary>Clears the value of the "callback_function" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearCallbackFunction() {
    callbackFunction_ = null;
  }

  /// <summary>Field number for the "descriptorsize" field.</summary>
  public const int DescriptorsizeFieldNumber = 20;
  private readonly static global::DescriptorSize DescriptorsizeDefaultValue = global::DescriptorSize.DsAuto;

  private global::DescriptorSize descriptorsize_;
  /// <summary>
  /// Select the size of field descriptors. This option has to be defined
  /// for the whole message, not per-field. Usually automatic selection is
  /// ok, but if it results in compilation errors you can increase the field
  /// size here.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::DescriptorSize Descriptorsize {
    get { if ((_hasBits0 & 131072) != 0) { return descriptorsize_; } else { return DescriptorsizeDefaultValue; } }
    set {
      _hasBits0 |= 131072;
      descriptorsize_ = value;
    }
  }
  /// <summary>Gets whether the "descriptorsize" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasDescriptorsize {
    get { return (_hasBits0 & 131072) != 0; }
  }
  /// <summary>Clears the value of the "descriptorsize" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearDescriptorsize() {
    _hasBits0 &= ~131072;
  }

  /// <summary>Field number for the "default_has" field.</summary>
  public const int DefaultHasFieldNumber = 23;
  private readonly static bool DefaultHasDefaultValue = false;

  private bool defaultHas_;
  /// <summary>
  /// Set default value for has_ fields.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool DefaultHas {
    get { if ((_hasBits0 & 1048576) != 0) { return defaultHas_; } else { return DefaultHasDefaultValue; } }
    set {
      _hasBits0 |= 1048576;
      defaultHas_ = value;
    }
  }
  /// <summary>Gets whether the "default_has" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasDefaultHas {
    get { return (_hasBits0 & 1048576) != 0; }
  }
  /// <summary>Clears the value of the "default_has" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearDefaultHas() {
    _hasBits0 &= ~1048576;
  }

  /// <summary>Field number for the "include" field.</summary>
  public const int IncludeFieldNumber = 24;
  private static readonly pb::FieldCodec<string> _repeated_include_codec
      = pb::FieldCodec.ForString(194);
  private readonly pbc::RepeatedField<string> include_ = new pbc::RepeatedField<string>();
  /// <summary>
  /// Extra files to include in generated `.pb.h`
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public pbc::RepeatedField<string> Include {
    get { return include_; }
  }

  /// <summary>Field number for the "exclude" field.</summary>
  public const int ExcludeFieldNumber = 26;
  private static readonly pb::FieldCodec<string> _repeated_exclude_codec
      = pb::FieldCodec.ForString(210);
  private readonly pbc::RepeatedField<string> exclude_ = new pbc::RepeatedField<string>();
  /// <summary>
  /// Automatic includes to exclude from generated `.pb.h`
  /// Same as nanopb_generator.py command line flag -x.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public pbc::RepeatedField<string> Exclude {
    get { return exclude_; }
  }

  /// <summary>Field number for the "package" field.</summary>
  public const int PackageFieldNumber = 25;
  private readonly static string PackageDefaultValue = "";

  private string package_;
  /// <summary>
  /// Package name that applies only for nanopb.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public string Package {
    get { return package_ ?? PackageDefaultValue; }
    set {
      package_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }
  /// <summary>Gets whether the "package" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasPackage {
    get { return package_ != null; }
  }
  /// <summary>Clears the value of the "package" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearPackage() {
    package_ = null;
  }

  /// <summary>Field number for the "type_override" field.</summary>
  public const int TypeOverrideFieldNumber = 27;
  private readonly static global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type TypeOverrideDefaultValue = global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type.Double;

  private global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type typeOverride_;
  /// <summary>
  /// Override type of the field in generated C code. Only to be used with related field types
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type TypeOverride {
    get { if ((_hasBits0 & 2097152) != 0) { return typeOverride_; } else { return TypeOverrideDefaultValue; } }
    set {
      _hasBits0 |= 2097152;
      typeOverride_ = value;
    }
  }
  /// <summary>Gets whether the "type_override" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasTypeOverride {
    get { return (_hasBits0 & 2097152) != 0; }
  }
  /// <summary>Clears the value of the "type_override" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearTypeOverride() {
    _hasBits0 &= ~2097152;
  }

  /// <summary>Field number for the "label_override" field.</summary>
  public const int LabelOverrideFieldNumber = 31;
  private readonly static global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label LabelOverrideDefaultValue = global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label.Optional;

  private global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label labelOverride_;
  /// <summary>
  /// Override of the label of the field (see FieldDescriptorProto.Label). Can be used to create
  /// fields which nanopb considers required in proto3, or whether nanopb treats the field as
  /// optional/required/repeated.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label LabelOverride {
    get { if ((_hasBits0 & 16777216) != 0) { return labelOverride_; } else { return LabelOverrideDefaultValue; } }
    set {
      _hasBits0 |= 16777216;
      labelOverride_ = value;
    }
  }
  /// <summary>Gets whether the "label_override" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasLabelOverride {
    get { return (_hasBits0 & 16777216) != 0; }
  }
  /// <summary>Clears the value of the "label_override" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearLabelOverride() {
    _hasBits0 &= ~16777216;
  }

  /// <summary>Field number for the "sort_by_tag" field.</summary>
  public const int SortByTagFieldNumber = 28;
  private readonly static bool SortByTagDefaultValue = true;

  private bool sortByTag_;
  /// <summary>
  /// Due to historical reasons, nanopb orders fields in structs by their tag number
  /// instead of the order in .proto. Set this to false to keep the .proto order.
  /// The default value will probably change to false in nanopb-0.5.0.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool SortByTag {
    get { if ((_hasBits0 & 4194304) != 0) { return sortByTag_; } else { return SortByTagDefaultValue; } }
    set {
      _hasBits0 |= 4194304;
      sortByTag_ = value;
    }
  }
  /// <summary>Gets whether the "sort_by_tag" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasSortByTag {
    get { return (_hasBits0 & 4194304) != 0; }
  }
  /// <summary>Clears the value of the "sort_by_tag" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearSortByTag() {
    _hasBits0 &= ~4194304;
  }

  /// <summary>Field number for the "fallback_type" field.</summary>
  public const int FallbackTypeFieldNumber = 29;
  private readonly static global::FieldType FallbackTypeDefaultValue = global::FieldType.FtCallback;

  private global::FieldType fallbackType_;
  /// <summary>
  /// Set the FT_DEFAULT field conversion strategy.
  /// A field that can become a static member of a c struct (e.g. int, bool, etc)
  /// will be a a static field.
  /// Fields with dynamic length are converted to either a pointer or a callback.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public global::FieldType FallbackType {
    get { if ((_hasBits0 & 8388608) != 0) { return fallbackType_; } else { return FallbackTypeDefaultValue; } }
    set {
      _hasBits0 |= 8388608;
      fallbackType_ = value;
    }
  }
  /// <summary>Gets whether the "fallback_type" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasFallbackType {
    get { return (_hasBits0 & 8388608) != 0; }
  }
  /// <summary>Clears the value of the "fallback_type" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearFallbackType() {
    _hasBits0 &= ~8388608;
  }

  /// <summary>Field number for the "initializer" field.</summary>
  public const int InitializerFieldNumber = 30;
  private readonly static string InitializerDefaultValue = "";

  private string initializer_;
  /// <summary>
  /// Override initializer used in generated MyMessage_init_zero and MyMessage_init_default macros
  /// By default decided automatically based on field default value and datatype.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public string Initializer {
    get { return initializer_ ?? InitializerDefaultValue; }
    set {
      initializer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }
  /// <summary>Gets whether the "initializer" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasInitializer {
    get { return initializer_ != null; }
  }
  /// <summary>Clears the value of the "initializer" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearInitializer() {
    initializer_ = null;
  }

  /// <summary>Field number for the "discard_unused_automatic_types" field.</summary>
  public const int DiscardUnusedAutomaticTypesFieldNumber = 33;
  private readonly static bool DiscardUnusedAutomaticTypesDefaultValue = true;

  private bool discardUnusedAutomaticTypes_;
  /// <summary>
  /// Discard unused types that are automatically generated by protoc if they are not actually
  /// needed. Currently this applies to map&lt; > types when the field is ignored by options.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool DiscardUnusedAutomaticTypes {
    get { if ((_hasBits0 & 67108864) != 0) { return discardUnusedAutomaticTypes_; } else { return DiscardUnusedAutomaticTypesDefaultValue; } }
    set {
      _hasBits0 |= 67108864;
      discardUnusedAutomaticTypes_ = value;
    }
  }
  /// <summary>Gets whether the "discard_unused_automatic_types" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasDiscardUnusedAutomaticTypes {
    get { return (_hasBits0 & 67108864) != 0; }
  }
  /// <summary>Clears the value of the "discard_unused_automatic_types" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearDiscardUnusedAutomaticTypes() {
    _hasBits0 &= ~67108864;
  }

  /// <summary>Field number for the "discard_deprecated" field.</summary>
  public const int DiscardDeprecatedFieldNumber = 35;
  private readonly static bool DiscardDeprecatedDefaultValue = false;

  private bool discardDeprecated_;
  /// <summary>
  /// Discard messages and fields marked with [deprecated = true] in the proto file.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool DiscardDeprecated {
    get { if ((_hasBits0 & 268435456) != 0) { return discardDeprecated_; } else { return DiscardDeprecatedDefaultValue; } }
    set {
      _hasBits0 |= 268435456;
      discardDeprecated_ = value;
    }
  }
  /// <summary>Gets whether the "discard_deprecated" field is set</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool HasDiscardDeprecated {
    get { return (_hasBits0 & 268435456) != 0; }
  }
  /// <summary>Clears the value of the "discard_deprecated" field</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void ClearDiscardDeprecated() {
    _hasBits0 &= ~268435456;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public override bool Equals(object other) {
    return Equals(other as NanoPBOptions);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public bool Equals(NanoPBOptions other) {
    if (ReferenceEquals(other, null)) {
      return false;
    }
    if (ReferenceEquals(other, this)) {
      return true;
    }
    if (MaxSize != other.MaxSize) return false;
    if (MaxLength != other.MaxLength) return false;
    if (MaxCount != other.MaxCount) return false;
    if (IntSize != other.IntSize) return false;
    if (EnumIntsize != other.EnumIntsize) return false;
    if (Type != other.Type) return false;
    if (LongNames != other.LongNames) return false;
    if (PackedStruct != other.PackedStruct) return false;
    if (PackedEnum != other.PackedEnum) return false;
    if (SkipMessage != other.SkipMessage) return false;
    if (NoUnions != other.NoUnions) return false;
    if (Msgid != other.Msgid) return false;
    if (AnonymousOneof != other.AnonymousOneof) return false;
    if (Proto3 != other.Proto3) return false;
    if (Proto3SingularMsgs != other.Proto3SingularMsgs) return false;
    if (EnumToString != other.EnumToString) return false;
    if (EnumValidate != other.EnumValidate) return false;
    if (FixedLength != other.FixedLength) return false;
    if (FixedCount != other.FixedCount) return false;
    if (SubmsgCallback != other.SubmsgCallback) return false;
    if (MangleNames != other.MangleNames) return false;
    if (CallbackDatatype != other.CallbackDatatype) return false;
    if (CallbackFunction != other.CallbackFunction) return false;
    if (Descriptorsize != other.Descriptorsize) return false;
    if (DefaultHas != other.DefaultHas) return false;
    if(!include_.Equals(other.include_)) return false;
    if(!exclude_.Equals(other.exclude_)) return false;
    if (Package != other.Package) return false;
    if (TypeOverride != other.TypeOverride) return false;
    if (LabelOverride != other.LabelOverride) return false;
    if (SortByTag != other.SortByTag) return false;
    if (FallbackType != other.FallbackType) return false;
    if (Initializer != other.Initializer) return false;
    if (DiscardUnusedAutomaticTypes != other.DiscardUnusedAutomaticTypes) return false;
    if (DiscardDeprecated != other.DiscardDeprecated) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public override int GetHashCode() {
    int hash = 1;
    if (HasMaxSize) hash ^= MaxSize.GetHashCode();
    if (HasMaxLength) hash ^= MaxLength.GetHashCode();
    if (HasMaxCount) hash ^= MaxCount.GetHashCode();
    if (HasIntSize) hash ^= IntSize.GetHashCode();
    if (HasEnumIntsize) hash ^= EnumIntsize.GetHashCode();
    if (HasType) hash ^= Type.GetHashCode();
    if (HasLongNames) hash ^= LongNames.GetHashCode();
    if (HasPackedStruct) hash ^= PackedStruct.GetHashCode();
    if (HasPackedEnum) hash ^= PackedEnum.GetHashCode();
    if (HasSkipMessage) hash ^= SkipMessage.GetHashCode();
    if (HasNoUnions) hash ^= NoUnions.GetHashCode();
    if (HasMsgid) hash ^= Msgid.GetHashCode();
    if (HasAnonymousOneof) hash ^= AnonymousOneof.GetHashCode();
    if (HasProto3) hash ^= Proto3.GetHashCode();
    if (HasProto3SingularMsgs) hash ^= Proto3SingularMsgs.GetHashCode();
    if (HasEnumToString) hash ^= EnumToString.GetHashCode();
    if (HasEnumValidate) hash ^= EnumValidate.GetHashCode();
    if (HasFixedLength) hash ^= FixedLength.GetHashCode();
    if (HasFixedCount) hash ^= FixedCount.GetHashCode();
    if (HasSubmsgCallback) hash ^= SubmsgCallback.GetHashCode();
    if (HasMangleNames) hash ^= MangleNames.GetHashCode();
    if (HasCallbackDatatype) hash ^= CallbackDatatype.GetHashCode();
    if (HasCallbackFunction) hash ^= CallbackFunction.GetHashCode();
    if (HasDescriptorsize) hash ^= Descriptorsize.GetHashCode();
    if (HasDefaultHas) hash ^= DefaultHas.GetHashCode();
    hash ^= include_.GetHashCode();
    hash ^= exclude_.GetHashCode();
    if (HasPackage) hash ^= Package.GetHashCode();
    if (HasTypeOverride) hash ^= TypeOverride.GetHashCode();
    if (HasLabelOverride) hash ^= LabelOverride.GetHashCode();
    if (HasSortByTag) hash ^= SortByTag.GetHashCode();
    if (HasFallbackType) hash ^= FallbackType.GetHashCode();
    if (HasInitializer) hash ^= Initializer.GetHashCode();
    if (HasDiscardUnusedAutomaticTypes) hash ^= DiscardUnusedAutomaticTypes.GetHashCode();
    if (HasDiscardDeprecated) hash ^= DiscardDeprecated.GetHashCode();
    if (_unknownFields != null) {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public override string ToString() {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void WriteTo(pb::CodedOutputStream output) {
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    output.WriteRawMessage(this);
  #else
    if (HasMaxSize) {
      output.WriteRawTag(8);
      output.WriteInt32(MaxSize);
    }
    if (HasMaxCount) {
      output.WriteRawTag(16);
      output.WriteInt32(MaxCount);
    }
    if (HasType) {
      output.WriteRawTag(24);
      output.WriteEnum((int) Type);
    }
    if (HasLongNames) {
      output.WriteRawTag(32);
      output.WriteBool(LongNames);
    }
    if (HasPackedStruct) {
      output.WriteRawTag(40);
      output.WriteBool(PackedStruct);
    }
    if (HasSkipMessage) {
      output.WriteRawTag(48);
      output.WriteBool(SkipMessage);
    }
    if (HasIntSize) {
      output.WriteRawTag(56);
      output.WriteEnum((int) IntSize);
    }
    if (HasNoUnions) {
      output.WriteRawTag(64);
      output.WriteBool(NoUnions);
    }
    if (HasMsgid) {
      output.WriteRawTag(72);
      output.WriteUInt32(Msgid);
    }
    if (HasPackedEnum) {
      output.WriteRawTag(80);
      output.WriteBool(PackedEnum);
    }
    if (HasAnonymousOneof) {
      output.WriteRawTag(88);
      output.WriteBool(AnonymousOneof);
    }
    if (HasProto3) {
      output.WriteRawTag(96);
      output.WriteBool(Proto3);
    }
    if (HasEnumToString) {
      output.WriteRawTag(104);
      output.WriteBool(EnumToString);
    }
    if (HasMaxLength) {
      output.WriteRawTag(112);
      output.WriteInt32(MaxLength);
    }
    if (HasFixedLength) {
      output.WriteRawTag(120);
      output.WriteBool(FixedLength);
    }
    if (HasFixedCount) {
      output.WriteRawTag(128, 1);
      output.WriteBool(FixedCount);
    }
    if (HasMangleNames) {
      output.WriteRawTag(136, 1);
      output.WriteEnum((int) MangleNames);
    }
    if (HasCallbackDatatype) {
      output.WriteRawTag(146, 1);
      output.WriteString(CallbackDatatype);
    }
    if (HasCallbackFunction) {
      output.WriteRawTag(154, 1);
      output.WriteString(CallbackFunction);
    }
    if (HasDescriptorsize) {
      output.WriteRawTag(160, 1);
      output.WriteEnum((int) Descriptorsize);
    }
    if (HasProto3SingularMsgs) {
      output.WriteRawTag(168, 1);
      output.WriteBool(Proto3SingularMsgs);
    }
    if (HasSubmsgCallback) {
      output.WriteRawTag(176, 1);
      output.WriteBool(SubmsgCallback);
    }
    if (HasDefaultHas) {
      output.WriteRawTag(184, 1);
      output.WriteBool(DefaultHas);
    }
    include_.WriteTo(output, _repeated_include_codec);
    if (HasPackage) {
      output.WriteRawTag(202, 1);
      output.WriteString(Package);
    }
    exclude_.WriteTo(output, _repeated_exclude_codec);
    if (HasTypeOverride) {
      output.WriteRawTag(216, 1);
      output.WriteEnum((int) TypeOverride);
    }
    if (HasSortByTag) {
      output.WriteRawTag(224, 1);
      output.WriteBool(SortByTag);
    }
    if (HasFallbackType) {
      output.WriteRawTag(232, 1);
      output.WriteEnum((int) FallbackType);
    }
    if (HasInitializer) {
      output.WriteRawTag(242, 1);
      output.WriteString(Initializer);
    }
    if (HasLabelOverride) {
      output.WriteRawTag(248, 1);
      output.WriteEnum((int) LabelOverride);
    }
    if (HasEnumValidate) {
      output.WriteRawTag(128, 2);
      output.WriteBool(EnumValidate);
    }
    if (HasDiscardUnusedAutomaticTypes) {
      output.WriteRawTag(136, 2);
      output.WriteBool(DiscardUnusedAutomaticTypes);
    }
    if (HasEnumIntsize) {
      output.WriteRawTag(144, 2);
      output.WriteEnum((int) EnumIntsize);
    }
    if (HasDiscardDeprecated) {
      output.WriteRawTag(152, 2);
      output.WriteBool(DiscardDeprecated);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(output);
    }
  #endif
  }

  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
    if (HasMaxSize) {
      output.WriteRawTag(8);
      output.WriteInt32(MaxSize);
    }
    if (HasMaxCount) {
      output.WriteRawTag(16);
      output.WriteInt32(MaxCount);
    }
    if (HasType) {
      output.WriteRawTag(24);
      output.WriteEnum((int) Type);
    }
    if (HasLongNames) {
      output.WriteRawTag(32);
      output.WriteBool(LongNames);
    }
    if (HasPackedStruct) {
      output.WriteRawTag(40);
      output.WriteBool(PackedStruct);
    }
    if (HasSkipMessage) {
      output.WriteRawTag(48);
      output.WriteBool(SkipMessage);
    }
    if (HasIntSize) {
      output.WriteRawTag(56);
      output.WriteEnum((int) IntSize);
    }
    if (HasNoUnions) {
      output.WriteRawTag(64);
      output.WriteBool(NoUnions);
    }
    if (HasMsgid) {
      output.WriteRawTag(72);
      output.WriteUInt32(Msgid);
    }
    if (HasPackedEnum) {
      output.WriteRawTag(80);
      output.WriteBool(PackedEnum);
    }
    if (HasAnonymousOneof) {
      output.WriteRawTag(88);
      output.WriteBool(AnonymousOneof);
    }
    if (HasProto3) {
      output.WriteRawTag(96);
      output.WriteBool(Proto3);
    }
    if (HasEnumToString) {
      output.WriteRawTag(104);
      output.WriteBool(EnumToString);
    }
    if (HasMaxLength) {
      output.WriteRawTag(112);
      output.WriteInt32(MaxLength);
    }
    if (HasFixedLength) {
      output.WriteRawTag(120);
      output.WriteBool(FixedLength);
    }
    if (HasFixedCount) {
      output.WriteRawTag(128, 1);
      output.WriteBool(FixedCount);
    }
    if (HasMangleNames) {
      output.WriteRawTag(136, 1);
      output.WriteEnum((int) MangleNames);
    }
    if (HasCallbackDatatype) {
      output.WriteRawTag(146, 1);
      output.WriteString(CallbackDatatype);
    }
    if (HasCallbackFunction) {
      output.WriteRawTag(154, 1);
      output.WriteString(CallbackFunction);
    }
    if (HasDescriptorsize) {
      output.WriteRawTag(160, 1);
      output.WriteEnum((int) Descriptorsize);
    }
    if (HasProto3SingularMsgs) {
      output.WriteRawTag(168, 1);
      output.WriteBool(Proto3SingularMsgs);
    }
    if (HasSubmsgCallback) {
      output.WriteRawTag(176, 1);
      output.WriteBool(SubmsgCallback);
    }
    if (HasDefaultHas) {
      output.WriteRawTag(184, 1);
      output.WriteBool(DefaultHas);
    }
    include_.WriteTo(ref output, _repeated_include_codec);
    if (HasPackage) {
      output.WriteRawTag(202, 1);
      output.WriteString(Package);
    }
    exclude_.WriteTo(ref output, _repeated_exclude_codec);
    if (HasTypeOverride) {
      output.WriteRawTag(216, 1);
      output.WriteEnum((int) TypeOverride);
    }
    if (HasSortByTag) {
      output.WriteRawTag(224, 1);
      output.WriteBool(SortByTag);
    }
    if (HasFallbackType) {
      output.WriteRawTag(232, 1);
      output.WriteEnum((int) FallbackType);
    }
    if (HasInitializer) {
      output.WriteRawTag(242, 1);
      output.WriteString(Initializer);
    }
    if (HasLabelOverride) {
      output.WriteRawTag(248, 1);
      output.WriteEnum((int) LabelOverride);
    }
    if (HasEnumValidate) {
      output.WriteRawTag(128, 2);
      output.WriteBool(EnumValidate);
    }
    if (HasDiscardUnusedAutomaticTypes) {
      output.WriteRawTag(136, 2);
      output.WriteBool(DiscardUnusedAutomaticTypes);
    }
    if (HasEnumIntsize) {
      output.WriteRawTag(144, 2);
      output.WriteEnum((int) EnumIntsize);
    }
    if (HasDiscardDeprecated) {
      output.WriteRawTag(152, 2);
      output.WriteBool(DiscardDeprecated);
    }
    if (_unknownFields != null) {
      _unknownFields.WriteTo(ref output);
    }
  }
  #endif

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public int CalculateSize() {
    int size = 0;
    if (HasMaxSize) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxSize);
    }
    if (HasMaxLength) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLength);
    }
    if (HasMaxCount) {
      size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxCount);
    }
    if (HasIntSize) {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) IntSize);
    }
    if (HasEnumIntsize) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) EnumIntsize);
    }
    if (HasType) {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
    }
    if (HasLongNames) {
      size += 1 + 1;
    }
    if (HasPackedStruct) {
      size += 1 + 1;
    }
    if (HasPackedEnum) {
      size += 1 + 1;
    }
    if (HasSkipMessage) {
      size += 1 + 1;
    }
    if (HasNoUnions) {
      size += 1 + 1;
    }
    if (HasMsgid) {
      size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Msgid);
    }
    if (HasAnonymousOneof) {
      size += 1 + 1;
    }
    if (HasProto3) {
      size += 1 + 1;
    }
    if (HasProto3SingularMsgs) {
      size += 2 + 1;
    }
    if (HasEnumToString) {
      size += 1 + 1;
    }
    if (HasEnumValidate) {
      size += 2 + 1;
    }
    if (HasFixedLength) {
      size += 1 + 1;
    }
    if (HasFixedCount) {
      size += 2 + 1;
    }
    if (HasSubmsgCallback) {
      size += 2 + 1;
    }
    if (HasMangleNames) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) MangleNames);
    }
    if (HasCallbackDatatype) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(CallbackDatatype);
    }
    if (HasCallbackFunction) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(CallbackFunction);
    }
    if (HasDescriptorsize) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) Descriptorsize);
    }
    if (HasDefaultHas) {
      size += 2 + 1;
    }
    size += include_.CalculateSize(_repeated_include_codec);
    size += exclude_.CalculateSize(_repeated_exclude_codec);
    if (HasPackage) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(Package);
    }
    if (HasTypeOverride) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) TypeOverride);
    }
    if (HasLabelOverride) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) LabelOverride);
    }
    if (HasSortByTag) {
      size += 2 + 1;
    }
    if (HasFallbackType) {
      size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackType);
    }
    if (HasInitializer) {
      size += 2 + pb::CodedOutputStream.ComputeStringSize(Initializer);
    }
    if (HasDiscardUnusedAutomaticTypes) {
      size += 2 + 1;
    }
    if (HasDiscardDeprecated) {
      size += 2 + 1;
    }
    if (_unknownFields != null) {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void MergeFrom(NanoPBOptions other) {
    if (other == null) {
      return;
    }
    if (other.HasMaxSize) {
      MaxSize = other.MaxSize;
    }
    if (other.HasMaxLength) {
      MaxLength = other.MaxLength;
    }
    if (other.HasMaxCount) {
      MaxCount = other.MaxCount;
    }
    if (other.HasIntSize) {
      IntSize = other.IntSize;
    }
    if (other.HasEnumIntsize) {
      EnumIntsize = other.EnumIntsize;
    }
    if (other.HasType) {
      Type = other.Type;
    }
    if (other.HasLongNames) {
      LongNames = other.LongNames;
    }
    if (other.HasPackedStruct) {
      PackedStruct = other.PackedStruct;
    }
    if (other.HasPackedEnum) {
      PackedEnum = other.PackedEnum;
    }
    if (other.HasSkipMessage) {
      SkipMessage = other.SkipMessage;
    }
    if (other.HasNoUnions) {
      NoUnions = other.NoUnions;
    }
    if (other.HasMsgid) {
      Msgid = other.Msgid;
    }
    if (other.HasAnonymousOneof) {
      AnonymousOneof = other.AnonymousOneof;
    }
    if (other.HasProto3) {
      Proto3 = other.Proto3;
    }
    if (other.HasProto3SingularMsgs) {
      Proto3SingularMsgs = other.Proto3SingularMsgs;
    }
    if (other.HasEnumToString) {
      EnumToString = other.EnumToString;
    }
    if (other.HasEnumValidate) {
      EnumValidate = other.EnumValidate;
    }
    if (other.HasFixedLength) {
      FixedLength = other.FixedLength;
    }
    if (other.HasFixedCount) {
      FixedCount = other.FixedCount;
    }
    if (other.HasSubmsgCallback) {
      SubmsgCallback = other.SubmsgCallback;
    }
    if (other.HasMangleNames) {
      MangleNames = other.MangleNames;
    }
    if (other.HasCallbackDatatype) {
      CallbackDatatype = other.CallbackDatatype;
    }
    if (other.HasCallbackFunction) {
      CallbackFunction = other.CallbackFunction;
    }
    if (other.HasDescriptorsize) {
      Descriptorsize = other.Descriptorsize;
    }
    if (other.HasDefaultHas) {
      DefaultHas = other.DefaultHas;
    }
    include_.Add(other.include_);
    exclude_.Add(other.exclude_);
    if (other.HasPackage) {
      Package = other.Package;
    }
    if (other.HasTypeOverride) {
      TypeOverride = other.TypeOverride;
    }
    if (other.HasLabelOverride) {
      LabelOverride = other.LabelOverride;
    }
    if (other.HasSortByTag) {
      SortByTag = other.SortByTag;
    }
    if (other.HasFallbackType) {
      FallbackType = other.FallbackType;
    }
    if (other.HasInitializer) {
      Initializer = other.Initializer;
    }
    if (other.HasDiscardUnusedAutomaticTypes) {
      DiscardUnusedAutomaticTypes = other.DiscardUnusedAutomaticTypes;
    }
    if (other.HasDiscardDeprecated) {
      DiscardDeprecated = other.DiscardDeprecated;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  public void MergeFrom(pb::CodedInputStream input) {
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    input.ReadRawMessage(this);
  #else
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
    if ((tag & 7) == 4) {
      // Abort on any end group tag.
      return;
    }
    switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8: {
          MaxSize = input.ReadInt32();
          break;
        }
        case 16: {
          MaxCount = input.ReadInt32();
          break;
        }
        case 24: {
          Type = (global::FieldType) input.ReadEnum();
          break;
        }
        case 32: {
          LongNames = input.ReadBool();
          break;
        }
        case 40: {
          PackedStruct = input.ReadBool();
          break;
        }
        case 48: {
          SkipMessage = input.ReadBool();
          break;
        }
        case 56: {
          IntSize = (global::IntSize) input.ReadEnum();
          break;
        }
        case 64: {
          NoUnions = input.ReadBool();
          break;
        }
        case 72: {
          Msgid = input.ReadUInt32();
          break;
        }
        case 80: {
          PackedEnum = input.ReadBool();
          break;
        }
        case 88: {
          AnonymousOneof = input.ReadBool();
          break;
        }
        case 96: {
          Proto3 = input.ReadBool();
          break;
        }
        case 104: {
          EnumToString = input.ReadBool();
          break;
        }
        case 112: {
          MaxLength = input.ReadInt32();
          break;
        }
        case 120: {
          FixedLength = input.ReadBool();
          break;
        }
        case 128: {
          FixedCount = input.ReadBool();
          break;
        }
        case 136: {
          MangleNames = (global::TypenameMangling) input.ReadEnum();
          break;
        }
        case 146: {
          CallbackDatatype = input.ReadString();
          break;
        }
        case 154: {
          CallbackFunction = input.ReadString();
          break;
        }
        case 160: {
          Descriptorsize = (global::DescriptorSize) input.ReadEnum();
          break;
        }
        case 168: {
          Proto3SingularMsgs = input.ReadBool();
          break;
        }
        case 176: {
          SubmsgCallback = input.ReadBool();
          break;
        }
        case 184: {
          DefaultHas = input.ReadBool();
          break;
        }
        case 194: {
          include_.AddEntriesFrom(input, _repeated_include_codec);
          break;
        }
        case 202: {
          Package = input.ReadString();
          break;
        }
        case 210: {
          exclude_.AddEntriesFrom(input, _repeated_exclude_codec);
          break;
        }
        case 216: {
          TypeOverride = (global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type) input.ReadEnum();
          break;
        }
        case 224: {
          SortByTag = input.ReadBool();
          break;
        }
        case 232: {
          FallbackType = (global::FieldType) input.ReadEnum();
          break;
        }
        case 242: {
          Initializer = input.ReadString();
          break;
        }
        case 248: {
          LabelOverride = (global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label) input.ReadEnum();
          break;
        }
        case 256: {
          EnumValidate = input.ReadBool();
          break;
        }
        case 264: {
          DiscardUnusedAutomaticTypes = input.ReadBool();
          break;
        }
        case 272: {
          EnumIntsize = (global::IntSize) input.ReadEnum();
          break;
        }
        case 280: {
          DiscardDeprecated = input.ReadBool();
          break;
        }
      }
    }
  #endif
  }

  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
  void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
    uint tag;
    while ((tag = input.ReadTag()) != 0) {
    if ((tag & 7) == 4) {
      // Abort on any end group tag.
      return;
    }
    switch(tag) {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
          break;
        case 8: {
          MaxSize = input.ReadInt32();
          break;
        }
        case 16: {
          MaxCount = input.ReadInt32();
          break;
        }
        case 24: {
          Type = (global::FieldType) input.ReadEnum();
          break;
        }
        case 32: {
          LongNames = input.ReadBool();
          break;
        }
        case 40: {
          PackedStruct = input.ReadBool();
          break;
        }
        case 48: {
          SkipMessage = input.ReadBool();
          break;
        }
        case 56: {
          IntSize = (global::IntSize) input.ReadEnum();
          break;
        }
        case 64: {
          NoUnions = input.ReadBool();
          break;
        }
        case 72: {
          Msgid = input.ReadUInt32();
          break;
        }
        case 80: {
          PackedEnum = input.ReadBool();
          break;
        }
        case 88: {
          AnonymousOneof = input.ReadBool();
          break;
        }
        case 96: {
          Proto3 = input.ReadBool();
          break;
        }
        case 104: {
          EnumToString = input.ReadBool();
          break;
        }
        case 112: {
          MaxLength = input.ReadInt32();
          break;
        }
        case 120: {
          FixedLength = input.ReadBool();
          break;
        }
        case 128: {
          FixedCount = input.ReadBool();
          break;
        }
        case 136: {
          MangleNames = (global::TypenameMangling) input.ReadEnum();
          break;
        }
        case 146: {
          CallbackDatatype = input.ReadString();
          break;
        }
        case 154: {
          CallbackFunction = input.ReadString();
          break;
        }
        case 160: {
          Descriptorsize = (global::DescriptorSize) input.ReadEnum();
          break;
        }
        case 168: {
          Proto3SingularMsgs = input.ReadBool();
          break;
        }
        case 176: {
          SubmsgCallback = input.ReadBool();
          break;
        }
        case 184: {
          DefaultHas = input.ReadBool();
          break;
        }
        case 194: {
          include_.AddEntriesFrom(ref input, _repeated_include_codec);
          break;
        }
        case 202: {
          Package = input.ReadString();
          break;
        }
        case 210: {
          exclude_.AddEntriesFrom(ref input, _repeated_exclude_codec);
          break;
        }
        case 216: {
          TypeOverride = (global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Type) input.ReadEnum();
          break;
        }
        case 224: {
          SortByTag = input.ReadBool();
          break;
        }
        case 232: {
          FallbackType = (global::FieldType) input.ReadEnum();
          break;
        }
        case 242: {
          Initializer = input.ReadString();
          break;
        }
        case 248: {
          LabelOverride = (global::Google.Protobuf.Reflection.FieldDescriptorProto.Types.Label) input.ReadEnum();
          break;
        }
        case 256: {
          EnumValidate = input.ReadBool();
          break;
        }
        case 264: {
          DiscardUnusedAutomaticTypes = input.ReadBool();
          break;
        }
        case 272: {
          EnumIntsize = (global::IntSize) input.ReadEnum();
          break;
        }
        case 280: {
          DiscardDeprecated = input.ReadBool();
          break;
        }
      }
    }
  }
  #endif

}

#endregion


#endregion Designer generated code
